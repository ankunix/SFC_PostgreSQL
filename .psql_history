\copy uniform_2_1000000 from ~/SyntheticData/uniform_data_1m/uniform_2_1000000.txt DELIMITER ',' CSV
\copy uniform_4_1000000 from ~/SyntheticData/uniform_data_1m/uniform_4_1000000.txt DELIMITER ',' CSV
\copy uniform_8_1000000 from ~/SyntheticData/uniform_data_1m/uniform_8_1000000.txt DELIMITER ',' CSV
\copy uniform_16_1000000 from ~/SyntheticData/uniform_data_1m/uniform_16_1000000.txt DELIMITER ',' CSV
\copy uniform_2_1000000 from ~/SyntheticData/uniform_data_1m/uniform_2_1000000.txt DELIMITER ',' CSV
\copy uniform_4_1000000 from ~/SyntheticData/uniform_data_1m/uniform_4_1000000.txt DELIMITER ',' CSV
\copy uniform_8_1000000 from ~/SyntheticData/uniform_data_1m/uniform_8_1000000.txt DELIMITER ',' CSV
\copy uniform_16_1000000 from ~/SyntheticData/uniform_data_1m/uniform_16_1000000.txt DELIMITER ',' CSV
\copy cluster_2_1000 from ~/SyntheticData/cluster_data_1k/cluster_2_1000.txt DELIMITER ',' CSV
\copy cluster_4_1000 from ~/SyntheticData/cluster_data_1k/cluster_4_1000.txt DELIMITER ',' CSV
\copy cluster_8_1000 from ~/SyntheticData/cluster_data_1k/cluster_8_1000.txt DELIMITER ',' CSV
\copy cluster_16_1000 from ~/SyntheticData/cluster_data_1k/cluster_16_1000.txt DELIMITER ',' CSV
\copy cluster_2_10000 from ~/SyntheticData/cluster_data_10k/cluster_2_10000.txt DELIMITER ',' CSV
\copy cluster_4_10000 from ~/SyntheticData/cluster_data_10k/cluster_4_10000.txt DELIMITER ',' CSV
\copy cluster_8_10000 from ~/SyntheticData/cluster_data_10k/cluster_8_10000.txt DELIMITER ',' CSV
\copy cluster_16_10000 from ~/SyntheticData/cluster_data_10k/cluster_16_10000.txt DELIMITER ',' CSV
CREATE TABLE HilbertAC_Uniform_2_1000 (  vkey text PRIMARY KEY,  id text references uniform_2_1000(id));
CREATE TABLE HilbertAC_Uniform_4_1000 (  vkey text PRIMARY KEY,  id text references uniform_4_1000(id));
CREATE TABLE HilbertAC_Uniform_8_1000 (  vkey text PRIMARY KEY,  id text references uniform_8_1000(id));
CREATE TABLE HilbertAC_Uniform_16_1000 (  vkey text PRIMARY KEY,  id text references uniform_16_1000(id));
CREATE TABLE HilbertAC_Uniform_2_10000 (  vkey text PRIMARY KEY,  id text references uniform_2_10000(id));
CREATE TABLE HilbertAC_Uniform_4_10000 (  vkey text PRIMARY KEY,  id text references uniform_4_10000(id));
CREATE TABLE HilbertAC_Uniform_8_10000 (  vkey text PRIMARY KEY,  id text references uniform_8_10000(id));
CREATE TABLE HilbertAC_Uniform_16_10000 (  vkey text PRIMARY KEY,  id text references uniform_16_10000(id));
CREATE TABLE HilbertAC_Uniform_2_100000 (  vkey text PRIMARY KEY,  id text references uniform_2_100000(id));
CREATE TABLE HilbertAC_Uniform_4_100000 (  vkey text PRIMARY KEY,  id text references uniform_4_100000(id));
CREATE TABLE HilbertAC_Uniform_8_100000 (  vkey text PRIMARY KEY,  id text references uniform_8_100000(id));
CREATE TABLE HilbertAC_Uniform_16_100000 (  vkey text PRIMARY KEY,  id text references uniform_16_100000(id));
CREATE TABLE HilbertAC_Uniform_2_1000000 (  vkey text PRIMARY KEY,  id text references uniform_2_1000000(id));
CREATE TABLE HilbertAC_Uniform_4_1000000 (  vkey text PRIMARY KEY,  id text references uniform_4_1000000(id));
CREATE TABLE HilbertAC_Uniform_8_1000000 (  vkey text PRIMARY KEY,  id text references uniform_8_1000000(id));
CREATE TABLE HilbertAC_Uniform_16_1000000 (  vkey text PRIMARY KEY,  id text references uniform_8_1000000(id));
CREATE TABLE HilbertAC_cluster_2_1000 (  vkey text PRIMARY KEY,  id text references cluster_2_1000(id));
CREATE TABLE HilbertAC_cluster_4_1000 (  vkey text PRIMARY KEY,  id text references cluster_4_1000(id));
CREATE TABLE HilbertAC_cluster_8_1000 (  vkey text PRIMARY KEY,  id text references cluster_8_1000(id));
CREATE TABLE HilbertAC_cluster_16_1000 (  vkey text PRIMARY KEY,  id text references cluster_16_1000(id));
CREATE TABLE HilbertAC_cluster_2_10000 (  vkey text PRIMARY KEY,  id text references cluster_2_10000(id));
CREATE TABLE HilbertAC_cluster_4_10000 (  vkey text PRIMARY KEY,  id text references cluster_4_10000(id));
CREATE TABLE HilbertAC_cluster_8_10000 (  vkey text PRIMARY KEY,  id text references cluster_8_10000(id));
CREATE TABLE HilbertAC_cluster_16_10000 (  vkey text PRIMARY KEY,  id text references cluster_16_10000(id));
CREATE TABLE range_u_2 (  id smallint,  dim0 bigint,  dim1 bigint  );
CREATE TABLE range_u_4 (  id smallint,  dim0 bigint,  dim1 bigint,  dim2 bigint,  dim3 bigint  );
\copy range_u_2 from ~/SyntheticData/range_query_uniform/range_u_2.txt DELIMITER ',' CSV
\copy range_u_4 from ~/SyntheticData/range_query_uniform/range_u_4.txt DELIMITER ',' CSV
\q
\d
\d
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0try:    cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1if ndim==2:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1elif ndim==4:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1elif ndim==8:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1elif ndim==16:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
create LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0try:    cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1if ndim==2:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1elif ndim==4:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1elif ndim==8:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1elif ndim==16:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
\timing 
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,10000,256);
select * from HilbertAC_D('Uniform',2,100000,256);
select * from HilbertAC_D('Uniform',2,100000,1024);
select * from HilbertAC_D('Uniform',2,1000000,1024);
\q
select * from HilbertAC_D('Uniform',2,1CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)000000,1024);
  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))limit=size/10for offset in range(0,size,limit):    if ndim==2:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    elif ndim==4:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1,dim2,dim3 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    elif ndim==8:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1,dim2,dim3,dim4,dim5,dim6,dim7 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    elif ndim==16:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1,dim2,dim3,dim4,dim5,dim6,dim7,dim8,dim9,dim10,dim11,dim12,dim13,dim14,dim15 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    else:        plpy.info("Unsupported dimensionality!")        return -2    plpy.info(str(100*offset/size)+"% Complete")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))limit=size/10for offset in range(0,size,limit):    if ndim==2:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    elif ndim==4:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1,dim2,dim3 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    elif ndim==8:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1,dim2,dim3,dim4,dim5,dim6,dim7 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    elif ndim==16:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1,dim2,dim3,dim4,dim5,dim6,dim7,dim8,dim9,dim10,dim11,dim12,dim13,dim14,dim15 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    else:        plpy.info("Unsupported dimensionality!")        return -2    plpy.info(str(100*offset/size)+"% Complete")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
\timing
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',4,1000,256);
select * from HilbertAC_D('Uniform',8,1000,256);
select * from HilbertAC_D('Uniform',16,1000,256);
select * from HilbertAC_D('Uniform',2,10000,256);
select * from HilbertAC_D('Uniform',4,10000,256);
select * from HilbertAC_D('Uniform',8,10000,256);
select * from HilbertAC_D('Uniform',16,10000,256);
select * from HilbertAC_D('Uniform',2,100000,256);
select * from HilbertAC_D('Uniform',2,100000,1024);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))limit=size/10for offset in range(0,size,limit):    if ndim==2:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    elif ndim==4:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1,dim2,dim3 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    elif ndim==8:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1,dim2,dim3,dim4,dim5,dim6,dim7 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    elif ndim==16:        try:            cursor = plpy.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1,dim2,dim3,dim4,dim5,dim6,dim7,dim8,dim9,dim10,dim11,dim12,dim13,dim14,dim15 limit "+str(limit)+" offset "+str(offset))        except plpy.SPIError:            return -1        for row in cursor:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1    else:        plpy.info("Unsupported dimensionality!")        return -2    plpy.info(str(100*(limit+offset)/size)+"% Complete")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,100000,1024);
select * from HilbertAC_D('Uniform',4,100000,1024);
select * from HilbertAC_D('Uniform',8,100000,1024);
select * from HilbertAC_D('Uniform',16,100000,1024);
select * from HilbertAC_D('Uniform',2,1000000,1024);
\q
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size)+" order by dim0,dim1,dim2,dim3 limit 100000 offset "+str(offset))except plpy.SPIError:    return -1if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        plpy.info(str(100*batch_size/size)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        plpy.info(str(100*batch_size/size)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        plpy.info(str(100*batch_size/size)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        plpy.info(str(100*batch_size/size)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
\timing
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',4,1000,256);
select * from HilbertAC_D('Uniform',8,1000,256);
select * from HilbertAC_D('Uniform',16,1000,256);
select * from HilbertAC_D('Uniform',2,10000,256);
select * from HilbertAC_D('Uniform',4,10000,256);
select * from HilbertAC_D('Uniform',8,10000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',4,1000,256);
select * from HilbertAC_D('Uniform',8,1000,256);
select * from HilbertAC_D('Uniform',8,1000,256);
select * from HilbertAC_D('Uniform',16,1000,256);
select * from HilbertAC_D('Uniform',2,10000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(batch_size/size)        plpy.info(str(100*done)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,10000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done=done+(batch_size/size)        plpy.info(str(100*done)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,10000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done=done+(100*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=batch_size/size        plpy.info(str(100*done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,10000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100*batch_size/size)        plpy.info(str(done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,10000,256);
select * from HilbertAC_D('Uniform',4,10000,256);
select * from HilbertAC_D('Uniform',8,10000,256);
select * from HilbertAC_D('Uniform',16,10000,256);
select * from HilbertAC_D('Uniform',2,100000,1024);
select * from HilbertAC_D('Uniform',4,100000,1024);
select * from HilbertAC_D('Uniform',8,100000,1024);
select * from HilbertAC_D('Uniform',16,100000,1024);
select * from HilbertAC_D('Uniform',2,1000000,1024);
\j.\q
\q
select count(*) from hilbertac_2_1000000;
\d;
/d
\d
select count(*) from hilbertac_uniform_2_1000000;
select count(*) from hilbertac_uniform_2_1000000;
select count(*) from hilbertac_uniform_2_100000;
select count(*) from hilbertac_uniform_2_100000;
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select count(*) from hilbertac_uniform_2_100000;
select count(*) from hilbertac_2_1000000;
select * from HilbertAC_D('Uniform',2,1000000,1024);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=100try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000000,1024);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathimport gcsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=100try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")        del rows        gc.collect()elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")        del rows        gc.collect()elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")        del rows        gc.collect()elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")        del rows        gc.collect()else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000000,1024);
\q
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathimport gcsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor('mainCursoe')    cursor.itersize=batch_size    cursor.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==8:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==16:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
\q
select * from HilbertAC_D('Uniform',2,1000000,1024);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathimport gcsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor('mainCursor')    cursor.itersize=batch_size    cursor.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==8:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==16:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000000,1024);
select * from HilbertAC_D('Uniform',2,1000000,1024);CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)
  RETURNS integerAS $$import sysimport mathimport gcsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("mainCursor")    cursor.itersize=batch_size    cursor.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==8:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==16:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000000,1024);
select * from HilbertAC_D('Uniform',2,1000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathimport gcsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("mainCursor")    cursor.execute("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==8:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==16:    for row in cursor:        id=int(row['id'])        vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetchone        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
From 9ad14957e7b4ae19667df3bb8cc2aa5ef5bf96c8 Mon Sep 17 00:00:00 2001From: =?UTF-8?q?Jan=20Urba=C5=84ski?= <wulczer@wulczer.org>Date: Tue, 13 Sep 2011 14:42:41 +0200Subject: [PATCH] Add cursor support to plpythonu.Exposes SPI cursors as plpythonu objects allowing processing largeresult sets without loading them entirely into memory, as plpy.executeis doing.--- doc/src/sgml/plpython.sgml                 |   80 ++++ src/pl/plpython/expected/plpython_spi.out  |  151 +++++++ src/pl/plpython/expected/plpython_test.out |    6 +- src/pl/plpython/plpython.c                 |  605 ++++++++++++++++++++++++++++ src/pl/plpython/sql/plpython_spi.sql       |  116 ++++++ 5 files changed, 955 insertions(+), 3 deletions(-)diff --git a/doc/src/sgml/plpython.sgml b/doc/src/sgml/plpython.sgmlindex eda2bbf..d08c3d1 100644*** a/doc/src/sgml/plpython.sgml--- b/doc/src/sgml/plpython.sgml*************** $$ LANGUAGE plpythonu;*** 892,897 ****--- 892,906 ----    </para>      <para>+     Note that calling <literal>plpy.execute</literal> will cause the entire+     result set to be read into memory. Only use that function when you are sure+     that the result set will be relatively small.  If you don't want to risk+     excessive memory usage when fetching large results,+     use <literal>plpy.cursor</literal> rather+     than <literal>plpy.execute</literal>.+   </para>+ +   <para>     For example:  <programlisting>  rv = plpy.execute("SELECT * FROM my_table", 5)*************** $$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,1000,256);CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)
  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,1000000,1024);
\q
diff --git a/doc/src/sgml/plpython.sgml b/doc/src/sgml/plpython.sgmlindex eda2bbf..d08c3d1 100644--- a/doc/src/sgml/plpython.sgml+++ b/doc/src/sgml/plpython.sgml@@ -892,6 +892,15 @@ $$ LANGUAGE plpythonu;   </para>    <para>+    Note that calling <literal>plpy.execute</literal> will cause the entire+    result set to be read into memory. Only use that function when you are sure+    that the result set will be relatively small.  If you don't want to risk+    excessive memory usage when fetching large results,+    use <literal>plpy.cursor</literal> rather+    than <literal>plpy.execute</literal>.+  </para>++  <para>    For example: <programlisting> rv = plpy.execute("SELECT * FROM my_table", 5)@@ -958,6 +967,77 @@ $$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000000,1024);
\q
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=10000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
\q
select * from HilbertAC_D('Uniform',2,1000000,1024);
\q
---- nested calls--CREATE FUNCTION nested_call_one(a text) RETURNS textAS'q = "SELECT nested_call_two(''%s'')" % ar = plpy.execute(q)return r[0]'LANGUAGE plpythonu ;
CREATE FUNCTION nested_call_two(a text) RETURNS textAS'q = "SELECT nested_call_three(''%s'')" % ar = plpy.execute(q)return r[0]'LANGUAGE plpythonu ;
CREATE FUNCTION nested_call_three(a text) RETURNS textAS'return a'LANGUAGE plpythonu ;
-- some spi stuffCREATE FUNCTION spi_prepared_plan_test_one(a text) RETURNS textAS'if "myplan" not in SD:q = "SELECT count(*) FROM users WHERE lname = $1"SD["myplan"] = plpy.prepare(q, [ "text" ])try:rv = plpy.execute(SD["myplan"], [a])return "there are " + str(rv[0]["count"]) + " " + str(a) + "s"except Exception, ex:plpy.error(str(ex))return None'LANGUAGE plpythonu;
CREATE FUNCTION spi_prepared_plan_test_nested(a text) RETURNS textAS'if "myplan" not in SD:q = "SELECT spi_prepared_plan_test_one(''%s'') as count" % aSD["myplan"] = plpy.prepare(q)try:rv = plpy.execute(SD["myplan"])if len(rv):return rv[0]["count"]except Exception, ex:plpy.error(str(ex))return None'LANGUAGE plpythonu;
CREATE FUNCTION join_sequences(s sequences) RETURNS textAS'if not s["multipart"]:return s["sequence"]q = "SELECT sequence FROM xsequences WHERE pid = ''%s''" % s["pid"]rv = plpy.execute(q)seq = s["sequence"]for r in rv:seq = seq + r["sequence"]return seq'LANGUAGE plpythonu;
CREATE FUNCTION spi_recursive_sum(a int) RETURNS intAS'r = 0if a > 1:    r = plpy.execute("SELECT spi_recursive_sum(%d) as a" % (a-1))[0]["a"]return a + r'LANGUAGE plpythonu;
---- spi and nested calls--select nested_call_one('pass this along');
select spi_prepared_plan_test_one('doe');
select spi_prepared_plan_test_one('smith');
select spi_prepared_plan_test_nested('smith');
SELECT join_sequences(sequences) FROM sequences;
SELECT join_sequences(sequences) FROM sequencesWHERE join_sequences(sequences) ~* '^A';
SELECT join_sequences(sequences) FROM sequencesWHERE join_sequences(sequences) ~* '^B';
SELECT spi_recursive_sum(10);
---- plan and result objects--CREATE FUNCTION result_metadata_test(cmd text) RETURNS intAS $$plan = plpy.prepare(cmd)plpy.info(plan.status()) # not really documented or usefulresult = plpy.execute(plan)if result.status() > 0:   plpy.info(result.colnames())   plpy.info(result.coltypes())   plpy.info(result.coltypmods())   return result.nrows()else:   return None$$ LANGUAGE plpythonu;
SELECT result_metadata_test($$SELECT 1 AS foo, '11'::text AS bar UNION SELECT 2, '22'$$);
SELECT result_metadata_test($$CREATE TEMPORARY TABLE foo1 (a int, b text)$$);
CREATE FUNCTION result_nrows_test(cmd text) RETURNS intAS $$result = plpy.execute(cmd)return result.nrows()$$ LANGUAGE plpythonu;
SELECT result_nrows_test($$SELECT 1$$);
SELECT result_nrows_test($$CREATE TEMPORARY TABLE foo2 (a int, b text)$$);
SELECT result_nrows_test($$INSERT INTO foo2 VALUES (1, 'one'), (2, 'two')$$);
SELECT result_nrows_test($$UPDATE foo2 SET b = '' WHERE a = 2$$);
CREATE FUNCTION result_len_test(cmd text) RETURNS intAS $$result = plpy.execute(cmd)return len(result)$$ LANGUAGE plpythonu;
SELECT result_len_test($$SELECT 1$$);
SELECT result_len_test($$CREATE TEMPORARY TABLE foo3 (a int, b text)$$);
SELECT result_len_test($$INSERT INTO foo3 VALUES (1, 'one'), (2, 'two')$$);
SELECT result_len_test($$UPDATE foo3 SET b= '' WHERE a = 2$$);
CREATE FUNCTION result_subscript_test() RETURNS voidAS $$result = plpy.execute("SELECT 1 AS c UNION SELECT 2 "                      "UNION SELECT 3 UNION SELECT 4")plpy.info(result[1]['c'])plpy.info(result[-1]['c'])plpy.info([item['c'] for item in result[1:3]])plpy.info([item['c'] for item in result[::2]])result[-1] = {'c': 1000}result[:2] = [{'c': 10}, {'c': 100}]plpy.info([item['c'] for item in result[:]])# raises TypeError, but the message differs on Python 2.6, so silence ittry:    plpy.info(result['foo'])except TypeError:    passelse:    assert False, "TypeError not raised"$$ LANGUAGE plpythonu;
SELECT result_subscript_test();
CREATE FUNCTION result_empty_test() RETURNS voidAS $$result = plpy.execute("select 1 where false")plpy.info(result[:])$$ LANGUAGE plpythonu;
SELECT result_empty_test();
CREATE FUNCTION result_str_test(cmd text) RETURNS textAS $$plan = plpy.prepare(cmd)result = plpy.execute(plan)return str(result)$$ LANGUAGE plpythonu;
SELECT result_str_test($$SELECT 1 AS foo UNION SELECT 2$$);
SELECT result_str_test($$CREATE TEMPORARY TABLE foo1 (a int, b text)$$);
-- cursor objectsCREATE FUNCTION simple_cursor_test() RETURNS int AS $$res = plpy.cursor("select fname, lname from users")does = 0for row in res:    if row['lname'] == 'doe':        does += 1return does$$ LANGUAGE plpythonu;
CREATE FUNCTION double_cursor_close() RETURNS int AS $$res = plpy.cursor("select fname, lname from users")res.close()res.close()$$ LANGUAGE plpythonu;
CREATE FUNCTION cursor_fetch() RETURNS int AS $$res = plpy.cursor("select fname, lname from users")assert len(res.fetch(3)) == 3assert len(res.fetch(3)) == 1assert len(res.fetch(3)) == 0assert len(res.fetch(3)) == 0try:    # use next() or __next__(), the method name changed in    # http://www.python.org/dev/peps/pep-3114/    try:        res.next()    except AttributeError:        res.__next__()except StopIteration:    passelse:    assert False, "StopIteration not raised"$$ LANGUAGE plpythonu;
CREATE FUNCTION cursor_mix_next_and_fetch() RETURNS int AS $$res = plpy.cursor("select fname, lname from users order by fname")assert len(res.fetch(2)) == 2item = Nonetry:    item = res.next()except AttributeError:    item = res.__next__()assert item['fname'] == 'rick'assert len(res.fetch(2)) == 1$$ LANGUAGE plpythonu;
CREATE FUNCTION fetch_after_close() RETURNS int AS $$res = plpy.cursor("select fname, lname from users")res.close()try:    res.fetch(1)except ValueError:    passelse:    assert False, "ValueError not raised"$$ LANGUAGE plpythonu;
CREATE FUNCTION next_after_close() RETURNS int AS $$res = plpy.cursor("select fname, lname from users")res.close()try:    try:        res.next()    except AttributeError:        res.__next__()except ValueError:    passelse:    assert False, "ValueError not raised"$$ LANGUAGE plpythonu;
CREATE FUNCTION cursor_fetch_next_empty() RETURNS int AS $$res = plpy.cursor("select fname, lname from users where false")assert len(res.fetch(1)) == 0try:    try:        res.next()    except AttributeError:        res.__next__()except StopIteration:    passelse:    assert False, "StopIteration not raised"$$ LANGUAGE plpythonu;
CREATE FUNCTION cursor_plan() RETURNS SETOF text AS $$plan = plpy.prepare(    "select fname, lname from users where fname like $1 || '%' order by fname",    ["text"])for row in plpy.cursor(plan, ["w"]):    yield row['fname']for row in plpy.cursor(plan, ["j"]):    yield row['fname']$$ LANGUAGE plpythonu;
CREATE FUNCTION cursor_plan_wrong_args() RETURNS SETOF text AS $$plan = plpy.prepare("select fname, lname from users where fname like $1 || '%'",                    ["text"])c = plpy.cursor(plan, ["a", "b"])$$ LANGUAGE plpythonu;
CREATE TYPE test_composite_type AS (  a1 int,  a2 varchar);
CREATE OR REPLACE FUNCTION plan_composite_args() RETURNS test_composite_type AS $$plan = plpy.prepare("select $1 as c1", ["test_composite_type"])res = plpy.execute(plan, [{"a1": 3, "a2": "label"}])return res[0]["c1"]$$ LANGUAGE plpythonu;
SELECT simple_cursor_test();
SELECT double_cursor_close();
SELECT cursor_fetch();
SELECT cursor_mix_next_and_fetch();
SELECT fetch_after_close();
SELECT next_after_close();
SELECT cursor_fetch_next_empty();
SELECT cursor_plan();
SELECT cursor_plan_wrong_args();
SELECT plan_composite_args();
---- nested calls--CREATE FUNCTION nested_call_one(a text) RETURNS textAS'q = "SELECT nested_call_two(''%s'')" % ar = plpy.execute(q)return r[0]'LANGUAGE plpythonu ;
CREATE FUNCTION nested_call_two(a text) RETURNS textAS'q = "SELECT nested_call_three(''%s'')" % ar = plpy.execute(q)return r[0]'LANGUAGE plpythonu ;
CREATE FUNCTION nested_call_three(a text) RETURNS textAS'return a'LANGUAGE plpythonu ;
-- some spi stuffCREATE FUNCTION spi_prepared_plan_test_one(a text) RETURNS textAS'if "myplan" not in SD:q = "SELECT count(*) FROM users WHERE lname = $1"SD["myplan"] = plpy.prepare(q, [ "text" ])try:rv = plpy.execute(SD["myplan"], [a])return "there are " + str(rv[0]["count"]) + " " + str(a) + "s"except Exception, ex:plpy.error(str(ex))return None'LANGUAGE plpythonu;
CREATE FUNCTION spi_prepared_plan_test_nested(a text) RETURNS textAS'if "myplan" not in SD:q = "SELECT spi_prepared_plan_test_one(''%s'') as count" % aSD["myplan"] = plpy.prepare(q)try:rv = plpy.execute(SD["myplan"])if len(rv):return rv[0]["count"]except Exception, ex:plpy.error(str(ex))return None'LANGUAGE plpythonu;
CREATE FUNCTION join_sequences(s sequences) RETURNS textAS'if not s["multipart"]:return s["sequence"]q = "SELECT sequence FROM xsequences WHERE pid = ''%s''" % s["pid"]rv = plpy.execute(q)seq = s["sequence"]for r in rv:seq = seq + r["sequence"]return seq'LANGUAGE plpythonu;
CREATE FUNCTION spi_recursive_sum(a int) RETURNS intAS'r = 0if a > 1:    r = plpy.execute("SELECT spi_recursive_sum(%d) as a" % (a-1))[0]["a"]return a + r'LANGUAGE plpythonu;
---- spi and nested calls--select nested_call_one('pass this along');
select spi_prepared_plan_test_one('doe');
select spi_prepared_plan_test_one('smith');
select spi_prepared_plan_test_nested('smith');
SELECT join_sequences(sequences) FROM sequences;
SELECT join_sequences(sequences) FROM sequencesWHERE join_sequences(sequences) ~* '^A';
SELECT join_sequences(sequences) FROM sequencesWHERE join_sequences(sequences) ~* '^B';
SELECT spi_recursive_sum(10);
---- plan and result objects--CREATE FUNCTION result_metadata_test(cmd text) RETURNS intAS $$plan = plpy.prepare(cmd)plpy.info(plan.status()) # not really documented or usefulresult = plpy.execute(plan)if result.status() > 0:   plpy.info(result.colnames())   plpy.info(result.coltypes())   plpy.info(result.coltypmods())   return result.nrows()else:   return None$$ LANGUAGE plpythonu;
SELECT result_metadata_test($$SELECT 1 AS foo, '11'::text AS bar UNION SELECT 2, '22'$$);
SELECT result_metadata_test($$CREATE TEMPORARY TABLE foo1 (a int, b text)$$);
CREATE FUNCTION result_nrows_test(cmd text) RETURNS intAS $$result = plpy.execute(cmd)return result.nrows()$$ LANGUAGE plpythonu;
SELECT result_nrows_test($$SELECT 1$$);
SELECT result_nrows_test($$CREATE TEMPORARY TABLE foo2 (a int, b text)$$);
SELECT result_nrows_test($$INSERT INTO foo2 VALUES (1, 'one'), (2, 'two')$$);
SELECT result_nrows_test($$UPDATE foo2 SET b = '' WHERE a = 2$$);
CREATE FUNCTION result_len_test(cmd text) RETURNS intAS $$result = plpy.execute(cmd)return len(result)$$ LANGUAGE plpythonu;
SELECT result_len_test($$SELECT 1$$);
SELECT result_len_test($$CREATE TEMPORARY TABLE foo3 (a int, b text)$$);
SELECT result_len_test($$INSERT INTO foo3 VALUES (1, 'one'), (2, 'two')$$);
SELECT result_len_test($$UPDATE foo3 SET b= '' WHERE a = 2$$);
CREATE FUNCTION result_subscript_test() RETURNS voidAS $$result = plpy.execute("SELECT 1 AS c UNION SELECT 2 "                      "UNION SELECT 3 UNION SELECT 4")plpy.info(result[1]['c'])plpy.info(result[-1]['c'])plpy.info([item['c'] for item in result[1:3]])plpy.info([item['c'] for item in result[::2]])result[-1] = {'c': 1000}result[:2] = [{'c': 10}, {'c': 100}]plpy.info([item['c'] for item in result[:]])# raises TypeError, but the message differs on Python 2.6, so silence ittry:    plpy.info(result['foo'])except TypeError:    passelse:    assert False, "TypeError not raised"$$ LANGUAGE plpythonu;
SELECT result_subscript_test();
CREATE FUNCTION result_empty_test() RETURNS voidAS $$result = plpy.execute("select 1 where false")plpy.info(result[:])$$ LANGUAGE plpythonu;
SELECT result_empty_test();
CREATE FUNCTION result_str_test(cmd text) RETURNS textAS $$plan = plpy.prepare(cmd)result = plpy.execute(plan)return str(result)$$ LANGUAGE plpythonu;
SELECT result_str_test($$SELECT 1 AS foo UNION SELECT 2$$);
SELECT result_str_test($$CREATE TEMPORARY TABLE foo1 (a int, b text)$$);
-- cursor objectsCREATE FUNCTION simple_cursor_test() RETURNS int AS $$res = plpy.cursor("select fname, lname from users")does = 0for row in res:    if row['lname'] == 'doe':        does += 1return does$$ LANGUAGE plpythonu;
CREATE FUNCTION double_cursor_close() RETURNS int AS $$res = plpy.cursor("select fname, lname from users")res.close()res.close()$$ LANGUAGE plpythonu;
CREATE FUNCTION cursor_fetch() RETURNS int AS $$res = plpy.cursor("select fname, lname from users")assert len(res.fetch(3)) == 3assert len(res.fetch(3)) == 1assert len(res.fetch(3)) == 0assert len(res.fetch(3)) == 0try:    # use next() or __next__(), the method name changed in    # http://www.python.org/dev/peps/pep-3114/    try:        res.next()    except AttributeError:        res.__next__()except StopIteration:    passelse:    assert False, "StopIteration not raised"$$ LANGUAGE plpythonu;
CREATE FUNCTION cursor_mix_next_and_fetch() RETURNS int AS $$res = plpy.cursor("select fname, lname from users order by fname")assert len(res.fetch(2)) == 2item = Nonetry:    item = res.next()except AttributeError:    item = res.__next__()assert item['fname'] == 'rick'assert len(res.fetch(2)) == 1$$ LANGUAGE plpythonu;
CREATE FUNCTION fetch_after_close() RETURNS int AS $$res = plpy.cursor("select fname, lname from users")res.close()try:    res.fetch(1)except ValueError:    passelse:    assert False, "ValueError not raised"$$ LANGUAGE plpythonu;
CREATE FUNCTION next_after_close() RETURNS int AS $$res = plpy.cursor("select fname, lname from users")res.close()try:    try:        res.next()    except AttributeError:        res.__next__()except ValueError:    passelse:    assert False, "ValueError not raised"$$ LANGUAGE plpythonu;
CREATE FUNCTION cursor_fetch_next_empty() RETURNS int AS $$res = plpy.cursor("select fname, lname from users where false")assert len(res.fetch(1)) == 0try:    try:        res.next()    except AttributeError:        res.__next__()except StopIteration:    passelse:    assert False, "StopIteration not raised"$$ LANGUAGE plpythonu;
CREATE FUNCTION cursor_plan() RETURNS SETOF text AS $$plan = plpy.prepare(    "select fname, lname from users where fname like $1 || '%' order by fname",    ["text"])for row in plpy.cursor(plan, ["w"]):    yield row['fname']for row in plpy.cursor(plan, ["j"]):    yield row['fname']$$ LANGUAGE plpythonu;
CREATE FUNCTION cursor_plan_wrong_args() RETURNS SETOF text AS $$plan = plpy.prepare("select fname, lname from users where fname like $1 || '%'",                    ["text"])c = plpy.cursor(plan, ["a", "b"])$$ LANGUAGE plpythonu;
CREATE TYPE test_composite_type AS (  a1 int,  a2 varchar);
CREATE OR REPLACE FUNCTION plan_composite_args() RETURNS test_composite_type AS $$plan = plpy.prepare("select $1 as c1", ["test_composite_type"])res = plpy.execute(plan, [{"a1": 3, "a2": "label"}])return res[0]["c1"]$$ LANGUAGE plpythonu;
SELECT simple_cursor_test();
SELECT double_cursor_close();
SELECT cursor_fetch();
SELECT cursor_mix_next_and_fetch();
SELECT fetch_after_close();
SELECT next_after_close();
SELECT cursor_fetch_next_empty();
SELECT cursor_plan();
SELECT cursor_plan_wrong_args();
SELECT plan_composite_args();
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=10000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('uniform',2,1000000,1024);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')def progress(count, total, suffix=''):    bar_len = 60    filled_len = int(round(bar_len * count / float(total)))    percents = round(100.0 * count / float(total), 1)    bar = '=' * filled_len + '-' * (bar_len - filled_len)    sys.stdout.write('[%s] %s%s ...%s\r' % (bar, percents, '%', suffix))    sys.stdout.flush()import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=100 sudo easy_install pip 0try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')def progress(count, total, suffix=''):    bar_len = 60    filled_len = int(round(bar_len * count / float(total)))    percents = round(100.0 * count / float(total), 1)    bar = '=' * filled_len + '-' * (bar_len - filled_len)    sys.stdout.write('[%s] %s%s ...%s\r' % (bar, percents, '%', suffix))    sys.stdout.flush()import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=100 sudo easy_install pip 0try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')def progress(count, total, suffix=''):    bar_len = 60    filled_len = int(round(bar_len * count / float(total)))    percents = round(100.0 * count / float(total), 1)    bar = '=' * filled_len + '-' * (bar_len - filled_len)    sys.stdout.write('[%s] %s%s ...%s\r' % (bar, percents, '%', suffix))    sys.stdout.flush()import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions and "+str(size)+" records.")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')def progress(count, total, suffix=''):    bar_len = 60    filled_len = int(round(bar_len * count / float(total)))    percents = round(100.0 * count / float(total), 1)    bar = '=' * filled_len + '-' * (bar_len - filled_len)    sys.stdout.write('[%s] %s%s ...%s\r' % (bar, percents, '%', suffix))    sys.stdout.flush()import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, status="Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from hilbertac_d('Uniform',2,10000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')def progress(count, total, suffix=''):    bar_len = 60    filled_len = int(round(bar_len * count / float(total)))    percents = round(100.0 * count / float(total), 1)    bar = '=' * filled_len + '-' * (bar_len - filled_len)    sys.stdout.write('[%s] %s%s ...%s\r' % (bar, percents, '%', suffix))    sys.stdout.flush()import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, "Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size,"Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, "Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, "Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from hilbertac_d('Uniform',2,10000,256);
select * from hilbertac_d('Uniform',2,100000,1024);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')def progress(count, total, suffix=''):    bar_len = 60    filled_len = int(round(bar_len * count / float(total)))    percents = round(100.0 * count / float(total), 1)    bar = '=' * filled_len + '-' * (bar_len - filled_len)    sys.stdout.write('[%s] %s%s ...%s\r' % (bar, percents, '%', suffix))    sys.stdout.flush()import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1done=0.00if ndim==2:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, "Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")elif ndim==4:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size,"Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")elif ndim==8:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, "Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")elif ndim==16:    while True:        rows = cursor.fetch(batch_size)        if not rows:            break        for row in rows:            id=int(row['id'])            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        progress(done,size, "Hilbert Key Generation for "+str(ndim)+" dimensions of "+str(data_category)+" having "+str(size)+" records.")else:    plpy.info("Unsupported dimensionality!")    return -2return count$$ LANGUAGE plpythonu;
select * from hilbertac_d('Uniform',2,100000,1024);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1done=0.00while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        id=int(row['id'])        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")            plpy.execute(plan,[vKey, id])            count+=1            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1done=0.00while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        id=int(row['id'])        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")            plpy.execute(plan,[vKey, id])            count+=1            plpy.execute(plan,[vKey, id])            count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1done=0.00while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        id=int(row['id'])        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000done=0.00try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        id=int(row['id'])        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*batch_size/size)        plpy.info(str(done)+"% Completed")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        id=int(row['id'])        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        plpy.execute(plan,[vKey, id])        count+=1        done+=(100.0*count/size)        plpy.info(str(done)+"% Completed")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        id=int(row['id'])        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        plpy.execute(plan,[vKey, id])        count+=1        plpy.info(str(100.0*count/size)+"% Completed")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        id=int(row['id'])        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        plpy.execute(plan,[vKey, id])        count+=1        plpy.info(str(100.00*count/size)+"% Completed")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',2,1000,256);
\timing
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',4,1000,256);
select * from HilbertAC_D('Uniform',8,1000,256);
select * from HilbertAC_D('Uniform',16,1000,256);
select * from HilbertAC_D('Uniform',2,10000,256);
select * from HilbertAC_D('Uniform',4,10000,256);
select * from HilbertAC_D('Uniform',8,10000,256);
select * from HilbertAC_D('Uniform',16,10000,256);
select * from HilbertAC_D('Uniform',2,100000,1024);
select * from HilbertAC_D('Uniform',4,100000,1024);
select * from HilbertAC_D('Uniform',8,100000,1024);
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import sysimport mathsys.path.append('/home/sdb/PyScripts')import hilberttotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))count=0batch_size=1000try:    plpy.execute("TRUNCATE HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size))    cursor = plpy.cursor("SELECT * FROM "+str(data_category)+"_"+str(ndim)+"_"+str(size))    plan=plpy.prepare("INSERT INTO HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+"(vkey,id) VALUES ($1,$2)", ["text", "text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        id=int(row['id'])        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        plpy.execute(plan,[vKey, id])        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_D('Uniform',8,100000,1024);
select * from HilbertAC_D('Uniform',8,100000,1024);
select * from HilbertAC_D('Uniform',16,100000,1024);
select * from HilbertAC_D('Uniform',2,1000000,1024);
select * from HilbertAC_D('Uniform',4,1000000,1024);
select * from HilbertAC_D('Uniform',8,1000000,1024);
CREATE OR REPLACE FUNCTION HilbertAC_PQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)x`  RETURNS integerAS $$import csvimport sysimport mathgrid_edge=1024totalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilberttry:    plan=plpy.prepare(""SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1with open('/home/sdb/SyntheticData/point_query_'+str(data_category).lower()+'/point_'+str(data_category).lower()+'_'+str(ndim)+'.txt', 'rU') as f:    reader = csv.reader(f)    rowCount=0    for row in reader:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)return rowCount$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_PQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import csvimport sysimport mathgrid_edge=1024totalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilberttry:    plan=plpy.prepare(""SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1with open('/home/sdb/SyntheticData/point_query_'+str(data_category).lower()+'/point_'+str(data_category).lower()+'_'+str(ndim)+'.txt', 'rU') as f:    reader = csv.reader(f)    rowCount=0    for row in reader:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)return rowCount$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_PQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import csvimport sysimport mathgrid_edge=1024totalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilberttry:    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1with open('/home/sdb/SyntheticData/point_query_'+str(data_category).lower()+'/point_'+str(data_category).lower()+'_'+str(ndim)+'.txt', 'rU') as f:    reader = csv.reader(f)    rowCount=0    for row in reader:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)return rowCount$$ LANGUAGE plpythonu;
select * from HilbertAC_PQ_D("Uniform",2,10000,256);
select * from HilbertAC_PQ_D('Uniform',2,10000,256);
CREATE OR REPLACE FUNCTION HilbertAC_PQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import csvimport sysimport mathgrid_edge=1024totalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilberttry:    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1with open('/home/sdb/SyntheticData/point_query_'+str(data_category).lower()+'/point_'+str(data_category).lower()+'_'+str(ndim)+'.txt', 'rU') as f:    reader = csv.reader(f)    rowCount=0    for row in reader:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row[1]),int(row[2]))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row[1]),int(row[2]),int(row[3]),int(row[4]))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row[1]),int(row[2]),int(row[3]),int(row[4]),int(row[5]),int(row[6]),int(row[7]),int(row[8]))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row[1]),int(row[2]),int(row[3]),int(row[4]),int(row[5]),int(row[6]),int(row[7]),int(row[8]),int(row[9]),int(row[10]),int(row[11]),int(row[12]),int(row[13]),int(row[14]),int(row[15]),int(row[16]))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)return rowCount$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_PQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import csvimport sysimport mathgrid_edge=1024totalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilberttry:    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1with open('/home/sdb/SyntheticData/point_query_'+str(data_category).lower()+'/point_'+str(data_category).lower()+'_'+str(ndim)+'.txt', 'rU') as f:    reader = csv.reader(f)    rowCount=0    for row in reader:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row[1]),int(row[2]))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row[1]),int(row[2]),int(row[3]),int(row[4]))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row[1]),int(row[2]),int(row[3]),int(row[4]),int(row[5]),int(row[6]),int(row[7]),int(row[8]))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row[1]),int(row[2]),int(row[3]),int(row[4]),int(row[5]),int(row[6]),int(row[7]),int(row[8]),int(row[9]),int(row[10]),int(row[11]),int(row[12]),int(row[13]),int(row[14]),int(row[15]),int(row[16]))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)return rowCount$$ LANGUAGE plpythonu;
select * from HilbertAC_PQ_D('Uniform',2,10000,256);
select * from HilbertAC_PQ_D('Uniform',4,10000,256);
select * from HilbertAC_PQ_D('Uniform',2,10000,256);
select * from HilbertAC_PQ_D('Uniform',4,10000,256);
select * from HilbertAC_PQ_D('Uniform',8,10000,256);
select * from HilbertAC_PQ_D('Uniform',16,10000,256);
CREATE OR REPLACE FUNCTION PQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer)  RETURNS integerAS $$import csvimport sysimport mathgrid_edge=1024totalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertwith open('/home/sdb/SyntheticData/PQ1000000/u_'+str(ndim)+'_'+str(size)+'.txt', 'rU') as f:    reader = csv.reader(f)    rowCount=0    if ndim==2:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    elif ndim==4:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"' AND dim2='"+str(row[3])+"' AND dim3='"+str(row[4])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    elif ndim==8:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"' AND dim2='"+str(row[3])+"' AND dim3='"+str(row[4])+"' AND dim4='"+str(row[5])+"' AND dim5='"+str(row[6])+"' AND dim6='"+str(row[7])+"' AND dim7='"+str(row[8])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    elif ndim==16:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"' AND dim2='"+str(row[3])+"' AND dim3='"+str(row[4])+"' AND dim4='"+str(row[5])+"' AND dim5='"+str(row[6])+"' AND dim6='"+str(row[7])+"' AND dim7='"+str(row[8])+"' AND dim8='"+str(row[9])+"' AND dim9='"+str(row[10])+"' AND dim10='"+str(row[11])+"' AND dim11='"+str(row[12])+"' AND dim12='"+str(row[13])+"' AND dim13='"+str(row[14])+"' AND dim14='"+str(row[15])+"' AND dim15='"+str(row[16])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    else:        plpy.info("Unsupported dimensionality!")        return -2return rowCount$$ LANGUAGE plpythonu;
select * from HilbertAC_PQ_D('Uniform',8,10000,256);
select * from PQ_D('Uniform',8,10000,256);
CREATE OR REPLACE FUNCTION PQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import csvimport sysimport mathgrid_edge=1024totalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertwith open('/home/sdb/SyntheticData/point_query_'+str(data_category).lower()+'/point_'+str(data_category).lower()+'_'+str(ndim)+"_"+str(size)+'.txt', 'rU') as f:    reader = csv.reader(f)    rowCount=0    if ndim==2:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    elif ndim==4:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"' AND dim2='"+str(row[3])+"' AND dim3='"+str(row[4])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    elif ndim==8:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"' AND dim2='"+str(row[3])+"' AND dim3='"+str(row[4])+"' AND dim4='"+str(row[5])+"' AND dim5='"+str(row[6])+"' AND dim6='"+str(row[7])+"' AND dim7='"+str(row[8])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    elif ndim==16:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"' AND dim2='"+str(row[3])+"' AND dim3='"+str(row[4])+"' AND dim4='"+str(row[5])+"' AND dim5='"+str(row[6])+"' AND dim6='"+str(row[7])+"' AND dim7='"+str(row[8])+"' AND dim8='"+str(row[9])+"' AND dim9='"+str(row[10])+"' AND dim10='"+str(row[11])+"' AND dim11='"+str(row[12])+"' AND dim12='"+str(row[13])+"' AND dim13='"+str(row[14])+"' AND dim14='"+str(row[15])+"' AND dim15='"+str(row[16])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    else:        plpy.info("Unsupported dimensionality!")        return -2return rowCount$$ LANGUAGE plpythonu;
select * from PQ_D('Uniform',8,10000,256);
CREATE OR REPLACE FUNCTION PQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer)  RETURNS integerAS $$import csvimport sysimport mathgrid_edge=1024totalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertwith open('/home/sdb/SyntheticData/point_query_'+str(data_category).lower()+'/point_'+str(data_category).lower()+'_'+str(ndim)+'.txt', 'rU') as f:    reader = csv.reader(f)    rowCount=0    if ndim==2:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    elif ndim==4:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"' AND dim2='"+str(row[3])+"' AND dim3='"+str(row[4])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    elif ndim==8:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"' AND dim2='"+str(row[3])+"' AND dim3='"+str(row[4])+"' AND dim4='"+str(row[5])+"' AND dim5='"+str(row[6])+"' AND dim6='"+str(row[7])+"' AND dim7='"+str(row[8])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    elif ndim==16:        for row in reader:            rv=plpy.execute("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE dim0='"+str(row[1])+"' AND dim1='"+str(row[2])+"' AND dim2='"+str(row[3])+"' AND dim3='"+str(row[4])+"' AND dim4='"+str(row[5])+"' AND dim5='"+str(row[6])+"' AND dim6='"+str(row[7])+"' AND dim7='"+str(row[8])+"' AND dim8='"+str(row[9])+"' AND dim9='"+str(row[10])+"' AND dim10='"+str(row[11])+"' AND dim11='"+str(row[12])+"' AND dim12='"+str(row[13])+"' AND dim13='"+str(row[14])+"' AND dim14='"+str(row[15])+"' AND dim15='"+str(row[16])+"'")            rowCount+=rv.nrows()            if(rv.nrows()!=0):              plpy.info(str(rowCount)+"\n"+str(rv))    else:        plpy.info("Unsupported dimensionality!")        return -2return rowCount$$ LANGUAGE plpythonu;
select * from PQ_D('Uniform',8,10000,256);
select * from PQ_D('Uniform',8,10000,256);
select * from PQ_D('Uniform',8,10000,256);
select * from PQ_D('Uniform',8,10000,256);
select * from PQ_D('Uniform',8,10000,256);
select * from PQ_D('Uniform',2,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',8,10000,256);
select * from PQ_D('Uniform',16,10000,256);
select * from PQ_D('Uniform',2,10000,256);
select * from PQ_D('Uniform',2,10000,256);
select * from PQ_D('Uniform',2,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',2,10000,256);
select * from PQ_D('Uniform',4,10000,256);
select * from PQ_D('Uniform',8,10000,256);
select * from PQ_D('Uniform',16,10000,256);
select * from HILBERTAC_PQ_D('Uniform',16,10000,256);
select * from HILBERTAC_PQ_D('Uniform',16,10000,256);
select * from HILBERTAC_PQ_D('Uniform',16,10000,256);
select * from HILBERTAC_PQ_D('Uniform',16,10000,256);
select * from HILBERTAC_PQ_D('Uniform',16,10000,256);
select * from HILBERTAC_PQ_D('Uniform',2,10000,256);
select * from HILBERTAC_PQ_D('Uniform',2,10000,256);
select * from HILBERTAC_PQ_D('Uniform',2,10000,256);
select * from HILBERTAC_PQ_D('Uniform',2,10000,256);
select * from HILBERTAC_PQ_D('Uniform',2,10000,256);
select * from HILBERTAC_PQ_D('Uniform',2,10000,256);
select * from HILBERTAC_PQ_D('Uniform',4,10000,256);
select * from HILBERTAC_PQ_D('Uniform',4,10000,256);
select * from HILBERTAC_PQ_D('Uniform',4,10000,256);
select * from HILBERTAC_PQ_D('Uniform',4,10000,256);
select * from HILBERTAC_PQ_D('Uniform',4,10000,256);
select * from HILBERTAC_PQ_D('Uniform',4,10000,256);
select * from HILBERTAC_PQ_D('Uniform',8,10000,256);
select * from HILBERTAC_PQ_D('Uniform',8,10000,256);
select * from HILBERTAC_PQ_D('Uniform',8,10000,256);
select * from HILBERTAC_PQ_D('Uniform',8,10000,256);
select * from HilbertAC_PQ_D("Uniform",2,10000,256);
select * from HilbertAC_D("Uniform",16,1000000,1024);
select * from HilbertAC_D('Uniform',16,1000000,1024);
select * from HilbertAC_D('cluster',2,1000,256);
select * from HilbertAC_D('cluster',4,1000,256);
select * from HilbertAC_D('cluster',2,1000,256);
select * from HilbertAC_D('cluster',2,1000,256);
select * from HilbertAC_D('cluster',2,1000,256);
select * from HilbertAC_D('cluster',4,1000,256);
select * from HilbertAC_D('cluster',4,1000,256);
select * from HilbertAC_D('cluster',4,1000,256);
select * from HilbertAC_D('cluster',4,1000,256);
select * from HilbertAC_D('cluster',8,1000,256);
select * from HilbertAC_D('cluster',8,1000,256);
select * from HilbertAC_D('cluster',16,1000,256);
select * from HilbertAC_D('cluster',2,10000,256);
select * from HilbertAC_D('cluster',2,10000,256);
select * from HilbertAC_D('cluster',4,10000,256);
select * from HilbertAC_D('cluster',8,10000,256);
select * from HilbertAC_D('cluster',16,10000,256);
\d
\d range_u_2
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilberttry:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000try:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000try:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000try:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
psql
\q
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000try:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000try:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000try:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)" where id="+str(mbrid))plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000try:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000try:    cursor = plpy.cursor("SELECT * FROM range_u_")    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000try:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000rowCount=0try:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000rowCount=0try:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=1000rowCount=0count=0try:    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/size)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
\timing
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
select * from HilbertAC_RQ_D('uniform',2,10000,256,1);
select * from HilbertAC_RQ_D('uniform',2,10000,256,2);
select * from HilbertAC_RQ_D('uniform',2,10000,256,1);
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
select * from HilbertAC_RQ_D('uniform',2,10000,256,3);
select * from HilbertAC_RQ_D('uniform',2,10000,256,2);
select * from HilbertAC_RQ_D('uniform',2,10000,256,3);
select * from HilbertAC_RQ_D('uniform',2,10000,256,3);
select * from HilbertAC_RQ_D('uniform',4,10000,256,0);
select count(1) from range_u_2 where id=0;
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=10000rowCount=0count=0try:    totalRangePoints =plpy.execute("select count(1) from range_u_"+str(ndim)+"where id="+str(mbrid))['count']    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/totalRangePoints)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select count(1) from range_u_2 where id=0;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=10000rowCount=0count=0try:    totalRangePoints=int(plpy.execute("select count(1) from range_u_"+str(ndim)+"where id="+str(mbrid))['count'])    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/totalRangePoints)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=10000rowCount=0count=0try:    totalRangePoints=int(plpy.execute("select count(1) from range_u_"+str(ndim)+" where id="+str(mbrid))['count'])    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/totalRangePoints)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=10000rowCount=0count=0try:    totalRangePoints=int(plpy.execute("select count(1) from range_u_"+str(ndim)+" where id="+str(mbrid))[0])    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/totalRangePoints)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=10000rowCount=0count=0try:    totalRangePoints=int(plpy.execute("select count(1) from range_u_"+str(ndim)+" where id="+str(mbrid))['count'])    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/totalRangePoints)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=10000rowCount=0count=0try:    totalRangePoints=int(plpy.execute("select count(1) from range_u_"+str(ndim)+" where id="+str(mbrid)))    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/totalRangePoints)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)
  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=10000rowCount=0count=0try:    totalRangePoints=int(plpy.execute("select count(1) from range_u_"+str(ndim)+" where id="+str(mbrid))[1]['count'])    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/totalRangePoints)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=10000rowCount=0count=0try:    totalRangePoints=int(plpy.execute("select count(1) from range_u_"+str(ndim)+" where id="+str(mbrid))[0]['count'])    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/totalRangePoints)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=10000rowCount=0count=0try:    totalRangePoints=int(plpy.execute("select count(1) from range_u_"+str(ndim)+" where id="+str(mbrid))[0]['count'])    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/totalRangePoints)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
CREATE OR REPLACE FUNCTION HilbertAC_RQ_D(DATA_CATEGORY text,NDIM integer,SIZE integer,GRID_EDGE integer, MBRID integer)  RETURNS integerAS $$import sysimport mathtotalPoints=grid_edge**ndimorder=int(math.log(totalPoints,4))sys.path.append('/home/sdb/PyScripts')import hilbertbatch_size=10000rowCount=0count=0try:    totalRangePoints=int(plpy.execute("select count(1) from range_u_"+str(ndim)+" where id="+str(mbrid))[0]['count'])    cursor = plpy.cursor("SELECT * FROM range_u_"+str(ndim)+" where id="+str(mbrid))    plan=plpy.prepare("SELECT * FROM "+data_category+"_"+str(ndim)+"_"+str(size)+" WHERE id=(select id from HilbertAC_"+str(data_category)+"_"+str(ndim)+"_"+str(size)+" where vkey=$1)", ["text"])except plpy.SPIError:    return -1while True:    rows = cursor.fetch(batch_size)    if not rows:        break    for row in rows:        if ndim==2:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']))))        elif ndim==4:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']))))        elif ndim==8:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']))))        elif ndim==16:            vKey=int(hilbert.hilbert_index(ndim, order, (int(row['dim0']),int(row['dim1']),int(row['dim2']),int(row['dim3']),int(row['dim4']),int(row['dim5']),int(row['dim6']),int(row['dim7']),int(row['dim8']),int(row['dim9']),int(row['dim10']),int(row['dim11']),int(row['dim12']),int(row['dim13']),int(row['dim14']),int(row['dim15']))))        else:            plpy.info("Unsupported dimensionality!")            return -2        rv=plpy.execute(plan,[vKey])        rowCount+=rv.nrows()        if(rv.nrows()!=0):              plpy.info(rv)        count+=1        plpy.info(str(100.00*count/totalRangePoints)+"%\tCompleted "+str(rowCount)+" rows found.")return count$$ LANGUAGE plpythonu;
select * from HilbertAC_RQ_D('uniform',2,10000,256,0);
select * from HilbertAC_RQ_D('uniform',4,10000,256,0);
\q
select * from HilbertAC_RQ_D('uniform',4,10000,256,1);
\timing 
select * from HilbertAC_RQ_D('uniform',4,10000,256,1);
select * from HilbertAC_RQ_D('uniform',4,10000,256,2);
select * from HilbertAC_RQ_D('uniform',4,10000,256,3);
select * from HilbertAC_PQ_D('cluster',4,10000,256);
\q
select * from HilbertAC_D('Uniform',2,10000,256);
\timing
\timing
\timing
select * from HilbertAC_D('Uniform',2,10000,256);
select * from HilbertAC_D('Uniform',2,1000,256);
select * from HilbertAC_D('Uniform',4,1000,256);
select * from HilbertAC_D('Uniform',8,1000,256);
select * from HilbertAC_D('Uniform',16,1000,256);
select * from HilbertAC_D('cluster',16,1000,256);
select * from HilbertAC_D('cluster',16,1000,256);
select * from HilbertAC_D('cluster',2,1000,256);
select * from HilbertAC_D('cluster',3,1000,256);
select * from HilbertAC_D('cluster',4,1000,256);
select * from HilbertAC_D('cluster',8,1000,256);
select * from HilbertAC_D('uniform',2,10000,256);
select * from HilbertAC_D('uniform',4,10000,256);
select * from HilbertAC_D('uniform',4,10000,256);
select * from HilbertAC_D('uniform',2,10000,256);
